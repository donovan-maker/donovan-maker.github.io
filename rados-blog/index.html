<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rados - Donovan-Maker's Blog</title>
    <link rel="stylesheet", href="./style.css">
</head>
<body>
    <div id="title-box">
        <div id="home-button">
            <a href="/"><img src="/img/home.png" alt="HOME" id="home-icon"></a>
        </div>
        <div id="title-text">
            <h1>Rados, the Really Awesome Disk Operating System</h1>
        </div>
    </div>
    <div id="about-box">
        <h2>What is Rados?</h2>
        <p>Rados is a disk operating system that runs off of legacy BIOS and boots up to 64-bit long mode so that it has full access to everything a modern processor can do without the burden of UEFI.</p>
    </div>
    <div id="blogs">
        <h2>Blogs</h2>
        <div class="blog">
            <h3>Booted to Long Mode (1/3/26 PM)</h3>
            <p>I remember previously using <a href="https://youtu.be/pXzortxPZR8">this tutorial from a guy named Poncho</a> on booting into 32 bit protected mode. I used that as the base for this commit.</p>
            <p>That video is in a series about making an OS from scratch and I have referenced that tutorial series several times in other projects and will most likely reference it several times in this one. I say this because there is another video in the series <a href="https://youtu.be/sk_ngabpwXQ?si=tki7VknoWoupHUKW">on going from protected mode into 64 bit long mode</a>, and I also used that in this commit.</p>
            <p>I'll walk you through what I have done to get into long mode:</p>
            <ol>
                <li>Set the A20 gate using the fast gate method, by enabling bit 2 of port 0x92.</li>
                <li>Loaded a minimal GDT for memory control and privilege settings.</li>
                <li>Set the bit in CR0 to enable protected mode.</li>
                <li>Made a far jump to clear any old real mode pipelining.</li>
                <li>Detected the ability to use CPUID and report it to the user if the CPU can't.</li>
                <li>Use the cpuid instruction to detect if long mode can be enabled and report it to the user if the CPU can't.</li>
                <li>Enable and setup identity paging to map memory.</li>
                <li>Change the GDT to 64 bits, this will enable long mode.</li>
                <li>Make one final far jump to clear the protected mode pipelining, then report to the user that long mode has been enabled.</li>
            </ol>
            <p>You probably know that after you leave real mode you can't access BIOS function calls, so you might be wondering how I'm writing to the screen. It's really simple, I'm just writing directly to 0xb8000 where the text data for the video card is mapped.</p>
            <p>I also removed my reservation for the FAT header as I couldn't figure out how to get WinImage to recognize it, even when I padded the file to 2MB and set all of the header fields properly. If anyone can help me in any way please make a comment on my copy of this blog on the Nanobyte Discord server.</p>
            <p>These changes belong to <a href="https://github.com/donovan-maker/rados/commit/cfa38b950d55790cacc8d6434b829d34cb7cefad">commit cf138b9</a>.</p>
        </div>
        <div class="blog">
            <h3>Added Memory Map Reading (1/2/26 AM)</h3>
            <p>In the OsDev wiki article it says that one of the next things that should be added is memory map reading so the kernel knows what memory it can use.</p>
            <p>Going to the <a href="https://wiki.osdev.org/Detecting_Memory_(x86)">detecting memory</a> article specifically for this I found a BIOS interrupt called with INT 15h AX=E820h that returns the memory map.</p>
            <p>After a long and grueling process I finally got it to read all of the memory maps, and if it is of type one move it to my buffer of 16 blocks so that later the kernel can access these blocks to see what memory it can use.</p>
            <p>I also have it print out a message saying how many megabytes it has free +/-2MB.</p>
            <p>These changes belong to <a href="https://github.com/donovan-maker/rados/commit/523631aa1ee68f78a3b3b7635fbf253c953c045c">commit 523631a</a>.</p>
        </div>
        <div class="blog">
            <h3>Added the Bootloader (1/1/26 PM)</h3>
            <p>I did some looking around on the OsDev wiki and found myself at <a href="https://wiki.osdev.org/Rolling_Your_Own_Bootloader">this article</a> about making your own bootloader. I am using the basic concepts from this to make the base for my bootloader.</p>
            <p>First I needed to be able to boot, so I added the code that does that and bam, it boots. But it's just a blinking cursor on the default SeaBIOS startup page, and nothing more.</p>
            <p>I needed a way to be able to read from the disk and print to the screen, so I added those and a bunch of error checking and if the following work then it will get to the last infinite loop without any errors.</p>
            <ol>
                <li>The booted disk can not be a floppy disk, it must be a disk drive, a flash drive (usb stick), or anything else that has a boot disk value of 0x80 or greater.</li>
                <li>The BIOS must support the enhanced disk drive services (called extended drive functions in my code) with functions AH=41h to AH=48h.</li>
                <li>Properly read one more sector from the disk to load the next 512 bytes of bootloader code/data.</li>
            </ol>
            <p>Assuming all of that works it will infinite loop (a psudo-boot for now) without any errors printed on the screen.</p>
            <p>These changes belong to <a href="https://github.com/donovan-maker/rados/commit/8621091957972f728c85f33cf441f763750a7b24">commit 8621091</a>.</p>
        </div>
    </div>
</body>
</html>
